(function (global, factory) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    global.Splitting = factory();
  }
})(this, function () {
  "use strict";

  var doc = document,
    textNode = doc.createTextNode.bind(doc);

  function setStyle(el, prop, value) {
    el.style.setProperty(prop, value);
  }

  function append(parent, child) {
    return parent.appendChild(child);
  }

  function createSpan(parent, className, content, key) {
    var span = doc.createElement("span");
    if (className) span.className = className;
    if (content)
      !key && span.setAttribute("data-" + className, content),
        (span.textContent = content);
    return (parent && append(parent, span)) || span;
  }

  function getData(el, key) {
    return el.getAttribute("data-" + key);
  }

  function getElements(selector, base) {
    return (base || doc).querySelectorAll(selector);
  }

  function createEmptyArrays(count) {
    var result = [];
    while (count--) result[count] = [];
    return result;
  }

  function forEach(items, fn) {
    items && items.some(fn);
  }

  function identity(item) {
    return item;
  }

  var instances = {};

  function createSplitting(key, dependencies, prop, splitFn) {
    return {
      by: key,
      depends: dependencies,
      key: prop,
      split: splitFn,
    };
  }

  function orderSplitterFn(a, b) {
    var indexA = a.indexOf("-") + 1 || a.length + 1;
    var indexB = b.indexOf("-") + 1 || b.length + 1;
    return indexA - indexB;
  }

  function resolveDependents(node, key, result) {
    return (function traverseTree(item, byKey, deps) {
      var index = deps.indexOf(item);
      if (index === -1) {
        deps.unshift(item);
        forEach(instances[item].depends, function (dependent) {
          traverseTree(dependent, item, deps);
        });
      } else {
        var dependentIndex = deps.indexOf(byKey);
        deps.splice(index, 1);
        deps.splice(dependentIndex, 0, item);
      }
      return deps;
    })(key, 0, []).map(identity);
  }

  var wordsKey = "words";
  var wordsSplitter = createSplitting(wordsKey, s, "word", function (node) {
    return splitWords(node, "word", /\s+/, 0, 1);
  });

  var charsKey = "chars";
  var charsSplitter = createSplitting(
    charsKey,
    [wordsKey],
    "char",
    function (node, prop, deps) {
      var result = [];
      forEach(deps[wordsKey], function (word, i) {
        result.push.apply(
          result,
          splitWords(word, "char", "", node.whitespace && i)
        );
      });
      return result;
    }
  );

  function Splitting(config) {
    var key = config.key;

    var instance = instances[key];

    if (!config.force && instance) {
      return instance;
    }

    instance = instances[key] = {
      el: config.el,
    };

    var allItems = [];

    function resolveSplits(node, prop, deps, shouldSetIndex) {
      var result = [];
      var fragment = doc.createDocumentFragment();
      var splitterKey = config.key + (shouldSetIndex ? "-index" : "");

      forEach(deps[key], function (dep, i) {
        if (Array.isArray(dep)) {
          forEach(dep, function (subDep) {
            shouldSetIndex && setStyle(subDep, splitterKey, i);
            append(fragment, subDep);
          });
        } else {
          shouldSetIndex && setStyle(dep, splitterKey, i);
          append(fragment, dep);
        }
      });

      setStyle(node, "--" + config.key + "-total", deps[key].length);
      append(node, fragment);

      var allChildren = getElements("[data-" + config.key + "-index]", node);
      forEach(allChildren, function (child, i) {
        var index = +getData(child, config.key + "-index");
        if (index !== i) {
          allChildren[i].style.order = i;
        }
      });

      forEach(allChildren, function (child) {
        var index = +getData(child, config.key + "-index");
        result[index] = child;
      });

      return result;
    }

    function splitWords(node, key, prop, deps) {
      node.normalize();
      var result = [];
      var fragment = doc.createDocumentFragment();
      deps.push(node.previousSibling);
      var items = [];

      var eachWord = function (node) {
        if (!node.tagName || node.hasChildNodes()) {
          if (node.childNodes && node.childNodes.length) {
            items.push(node);
            result.push.apply(result, splitWords(node, key, prop, deps));
          } else {
            var text = node.wholeText || "";
            var trimmed = text.trim();

            if (trimmed.length) {
              if (text[0] === " ") items.push(textNode(" "));

              forEach(trimmed.split(/\s+/), function (word, i) {
                i &&
                  config.whitespace &&
                  items.push(createSpan(fragment, "whitespace", " ", key));
                var element = createSpan(fragment, prop, word, key);
                items.push(element);
              });

              if (text[text.length - 1] === " ") items.push(textNode(" "));
            }
          }
        } else {
          items.push(node);
        }
      };

      forEach(node.childNodes, eachWord);

      forEach(items, function (item) {
        append(fragment, item);
      });

      forEach(items, function (item) {
        append(node, item);
      });

      return result;
    }

    function createSplit(node, key, prop, splitFn) {
      var prevContent = node.getAttribute("data-" + key);
      var textContent = node.textContent;
      var items;

      if (prevContent !== textContent || !config.force) {
        if (config.force || !prevContent)
          node.setAttribute("data-" + key, textContent);
        items = splitFn(node, prop, deps);
      } else {
        items = deps[key];
      }

      var keyDependents = resolveDependents(node, key, deps);

      resolveSplits(node, prop, keyDependents, 1);

      forEach(keyDependents, function (dependent, i) {
        resolveSplits(dependent, prop, keyDependents);
      });

      allItems.push.apply(allItems, items);
      return items;
    }

    var dependencies = config.by || getData(config.el, "splitting") || charsKey;

    var splitterFns = resolveDependents(null, key, {});
    var dependenciesResolved = splitterFns.map(identity);

    forEach(dependenciesResolved, function (splitterFn) {
      if (splitterFn.split) {
        var prop = splitterFn.by;
        var keyDependents = resolveDependents(null, key, {});
        var deps = {
          key: dependenciesResolved,
          depends: keyDependents,
        };
        var items = splitterFn.split(config.el, config, deps);

        if (prop) {
          node.classList.add(prop);
        }

        forEach(keyDependents, function (dependent, i) {
          resolveSplits(dependent, prop, deps);
        });

        allItems.push.apply(allItems, items);
      }
    });

    config.el.classList.add("splitting");

    instance.revert = function () {
      forEach(allItems, function (item) {
        item.style.order = "";
        item.style.setProperty("--" + config.key + "-total", "");
      });
      config.el.innerHTML = "";
    };

    return instance;
  }

  Splitting.html = function (config) {
    var div = createSpan();
    div.innerHTML = config.content;
    Splitting(config);
    return div.outerHTML;
  };

  Splitting.add = function (splitting) {
    var key = splitting.by;
    instances[key] = splitting;
  };

  Splitting.add(wordsSplitter);
  Splitting.add(charsSplitter);

  var linesSplitter = createSplitting(
    "lines",
    [wordsKey],
    "line",
    function (node, prop, deps) {
      return resolveDependents(node, key, deps).map(function (dep) {
        return dep;
      });
    }
  );
  Splitting.add(linesSplitter);

  var itemsSplitter = createSplitting(
    "items",
    s,
    "item",
    function (node, prop) {
      return m(config.matching || node.children, config);
    }
  );
  Splitting.add(itemsSplitter);

  var rowsSplitter = createSplitting("rows", s, "row", function (node, prop) {
    return N(node, config, "offsetTop");
  });
  Splitting.add(rowsSplitter);

  var colsSplitter = createSplitting("cols", s, "col", function (node, prop) {
    return N(node, config, "offsetLeft");
  });
  Splitting.add(colsSplitter);

  var gridSplitter = createSplitting(
    "grid",
    ["rows", "cols"],
    "",
    function (node, prop) {
      var rows = +(config.rows || getData(node, "rows") || 1);
      var cols = +(config.columns || getData(node, "columns") || 1);
      if (config.image) {
        var img = getElements("img", node)[0];
        config.image = img && (img.currentSrc || img.src);
      }
      config.image &&
        setStyle(node, "background-image", "url(" + config.image + ")");
      var cells = o(rows);
      forEach(cells, function (cell) {
        var innerCell = p(cell, "cell-inner");
      });

      return cells;
    }
  );
  Splitting.add(gridSplitter);

  var cellRowsSplitter = createSplitting(
    "cellRows",
    [M],
    "row",
    function (node, prop, deps) {
      var rows = config.rows;
      var result = o(rows);

      forEach(deps[M], function (cell, i) {
        result[Math.floor(i / (cell.length / rows))].push(cell);
      });

      return result;
    }
  );
  Splitting.add(cellRowsSplitter);

  var cellColumnsSplitter = createSplitting(
    "cellColumns",
    [M],
    "col",
    function (node, prop, deps) {
      var cols = config.columns;
      var result = o(cols);

      forEach(deps[M], function (cell, i) {
        result[i % cols].push(cell);
      });

      return result;
    }
  );
  Splitting.add(cellColumnsSplitter);

  var cellsSplitter = createSplitting(
    "cells",
    ["cellRows", "cellColumns"],
    "cell",
    function (node, prop, deps) {
      return deps[M];
    }
  );
  Splitting.add(cellsSplitter);

  return Splitting;
});
